#include "BeaconDetector.h"
#include <iostream>
#include <cmath>

#define NUM_BEACON_CANDIDATES 40
#define XTHRESHOLD 5
#define YTHRESHOLD 5
#define XDIST 2
#define YDIST 2
#define TBDIVIDE 8

using namespace Eigen;

#define getball() (&vblocks_.world_object->objects_[WO_BALL])
#define getself() (&vblocks_.world_object->objects_[vblocks_.robot_state->WO_SELF])
#define getframe() vblocks_.frame_info->frame_id

BeaconDetector::BeaconDetector(DETECTOR_DECLARE_ARGS, Classifier*& classifier, BlobDetector*& blob_detector) : DETECTOR_INITIALIZE, classifier_(classifier), blob_detector_(blob_detector) 
{
	candidateCount = 0;
  	candidates.reserve(NUM_BEACON_CANDIDATES);
}

void BeaconDetector::detectBeacon(bool topCamera)
{
	// The horizontalBlob elements do not work for the YELLOW and BLUE colors
	blob_detector_->formBlobs(c_PINK);
	blob_detector_->formBlobs(c_YELLOW); // YELLOW -> ORANGE
	blob_detector_->formBlobs(c_BLUE); // BLUE -> FIELD_GREEN
	BlobCollection& pinkBlobs = blob_detector_->horizontalBlob[c_PINK];
	BlobCollection& yellowBlobs = blob_detector_->horizontalBlob[c_ORANGE];
	BlobCollection& blueBlobs = blob_detector_->horizontalBlob[c_FIELD_GREEN];
	findCandidates(pinkBlobs, yellowBlobs);
	findCandidates(pinkBlobs, blueBlobs);
	findCandidates(yellowBlobs, pinkBlobs);
	findCandidates(yellowBlobs, blueBlobs);
	findCandidates(blueBlobs, pinkBlobs);
	findCandidates(blueBlobs, yellowBlobs);

	classifyBeacon();
}

void BeaconDetector::classifyBeacon()
{
	for(size_t i = 0; i < candidates.size(); ++i)
	{
		Candidate& c = candidates[i];
		if(c.valid)
		{
			WorldObject* wo = NULL;
			if(topColor == c_PINK)
			{
				if(bottomColor == C_YELLOW)
				{
					wo = &vblocks_.world_object->objects_[WO_BEACON_PINK_YELLOW]; 
				}
				else
				{
					wo = &vblocks_.world_object->objects_[WO_BEACON_PINK_BLUE]; 
				}
			}
			else if(topColor == c_YELLOW)
			{
				if(bottomColor == C_PINK)
				{
					wo = &vblocks_.world_object->objects_[WO_BEACON_YELLOW_PINK]; 
				}
				else
				{
					wo = &vblocks_.world_object->objects_[WO_BEACON_YELLOW_BLUE]; 
				}
			}
			else
			{
				if(bottomColor == C_YELLOW)
				{
					wo = &vblocks_.world_object->objects_[WO_BEACON_BLUE_YELLOW]; 
				}
				else
				{

					wo = &vblocks_.world_object->objects_[WO_BEACON_BLUE_PINK]; 
				}
			}
			wo->width = c.width;
			wo->height = c.height;
			wo->imageCenterX = c.centerX;
			wo->imageCenterY = c.centerY;
			wo->fromTopCamera = c.topCamera;
			wo->seen = true;
		}
	}
}

// The x coordinate of the centroid of each section must lie within the x range values of that of the other section
bool BeaconDetector::isValidCentroid(uint16_t centroidX, uint16_t xi, uint16_t xf, uint16_t offset) 
{
	return (centroidX >= xi - offset) && (centroidX <= xf + offset);
}

void BeaconDetector::findCandidates(BlobCollection& t, BlobCollection& b)
{
	for(size_t tn = 0; tn < t.size(); ++tn)
	{
		for(size_t bn = 0; 
	}
}

bool BeaconDetector::findBeacon(BlobCollection& t, BlobCollection& b, bool topCamera, Color topColor, Color BottomColor)
{
	for(size_t tn = 0; tn < t.size(); ++tn)
	{
		for(size_t bn = 0; bn < b.size(); ++bn)
		{
			cout << "*** finding beacon ***" << endl;
			cout << "*** top-x " << topBlob.xi << " top-y " << topBlob.yi << endl; 
			cout << "*** bottom-x " << bottomBlob.xi << " bottom-y " << bottomBlob.yi << endl; 
			if(bottomBlob.yi < topBlob.yi)
			{
				cout << "*** bottom blob on top of top blob" << endl;
				continue;
			}
			if(bottomBlob.yi - topBlob.yf > TBDIVIDE)
			{
				cout << "*** distance between top and bottom blob: " << bottomBlob.yi - topBlob.yf << endl;
				continue;
			}
			//uint16_t diffxpos = abs(topBlob.xi - bottomBlob.xi);
			//if(diffxpos > 0.20 * topBlob.dx)
			//{
			//	cout << "*** top bottom x offset " << diffxpos << " threshold " << (0.20 * topBlob.dx) << endl;
			//	return false;
			//}
			if (!isValidCentroid(topBlob.avgX, bottomBlob.xi, bottomBlob.xf, 0) || !isValidCentroid(bottomBlob.avgX, topBlob.xi, topBlob.xf, 0))
			{
				cout << "*** centroid" << endl;
				continue;
			}
			float top_aspect_ratio = ((float) topBlob.dy) / ((float) topBlob.dx);
			float bottom_aspect_ratio = ((float) bottomBlob.dy) / ((float) bottomBlob.dx);
			if(abs(top_aspect_ratio - 1) > 0.20f && abs(bottom_aspect_ratio - 1) > 0.20f)
			{
				cout << "*** top aspect ratio " << abs(top_aspect_ratio - 1) << endl;
				cout << "*** bottom aspect ratio " << abs(bottom_aspect_ratio - 1) << endl;
				continue;
			}
			cout << "*** valid beacon" << endl;
			BeaconCandidate bCandidate;
			bCandidate.width = max(topBlob.dx, bottomBlob.dx);
			bCandidate.height = topBlob.dy + bottomBlob.dy;
			bCandidate.centerX = topBlob.xi + (beacon->width / 2);
			bCandidate.centerY = topBlob.yi + (beacon->height / 2);
			bCandidate.valid = true;
			bCandidate.fromTopCamera = topCamera;
			bCandidate.topColor = topColor;
			bCandidate.bottomColor = bottomColor;
			candidates.push_back(bCandidate);
			return true;
		}
	}
}
