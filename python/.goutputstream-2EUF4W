from state import * 
import commands, core, util, pose, percepts, kicks
import time
import math

scoreDistance = 15
angle = 10
kp = 0.2
kd = 0.1
ki = 0.0

previous_error = 0
integralAngleError = 0

previous_ball_angle = 0

previous_ball_distance = 0
ball_distance = 0

prev_robot_angle = 0

#For Penalty task
class PenaltyKick(StateMachine):
  def setup(self):
    start = Node()
    choose = ChoosePenaltyNode()
    search = SearchNode()
    forward = WalkForwardPenaltyNode()
    detectGoal = DetectGoalNode()
    detectScore = DetectScore()
    finish = Node()
    align = AlignRightNode()
    
    self._adt(start, N, choose)
    self._adt(choose, S(Choices.Search), search, S, choose)
    self._adt(choose, S(Choices.DetectGoal), detectGoal)
    self._adt(detectGoal, S(Choices.WalkForwardPenalty), forward)
    self._adt(forward, S(Choices.WalkForwardPenalty), forward)
    self._adt(forward, S(Choices.LeftKick), LeftKickNode(), S, detectScore)
    self._adt(forward, S(Choices.RightKick), RightKickNode(), S, detectScore)
    self._adt(detectScore, S(Choices.Choose), choose)
    self._adt(detectScore, S(Choices.Finish), finish)
    self._adt(forward, S(Choices.Align), AlignRightNode())
    self._adt(align, S(Choices.Align), align)
    self._adt(align, S(Choices.LeftKick), LeftKickNode(), S, detectScore)
    self._adt(align, S(Choices.RightKick), RightKickNode(), S, detectScore)
    self._adt(align, S(Choices.Finish), finish)

#For Penalty task
class ChoosePenaltyNode(Node):
  def run(self):
    global angle
    global previous_error
    global previous_ball_angle
    global ball_distance
    global previous_ball_distance
    global integralAngleError
    
    goal = core.world_objects.getObjPtr(core.WO_OPP_GOAL)
    ball = core.world_objects.getObjPtr(core.WO_BALL)
    penalty_line = core.world_objects.getObjPtr(core.WO_OPP_PENALTY)

    #print "** seen line " + str(penalty_line.seen) + " top camera: " + str(penalty_line.fromTopCamera)
    commands.stand()
    commands.setHeadTilt(-10)
    #commands.setHeadTilt(-20) #tilt head down
    #commands.setWalkVelocity(0.4, 0.2, 0)
    '''if penalty_line.seen and penalty_line.imageCenterY > 160:
        print "** line x " + str(penalty_line.imageCenterX)
        print "** line y " + str(penalty_line.imageCenterY)
        print "** size of blob line " + str(penalty_line.radius)
        commands.stand()
    else:
        commands.setWalkVelocity(0.4, 0.2, 0)'''
    #commands.setWalkVelocity(0.4, 0.0, 0)
    print "** SEEN ** " + str(ball.seen)
    print "** imageX ** " + str(ball.imageCenterX)
    print "** imageY ** " + str(ball.imageCenterY)

    robotX = 160
    robotY = 240
    diffX = robotX - ball.imageCenterX
    diffY = robotY - ball.imageCenterY
    if ball.seen:
      core.speech.say("Seen")
      print "** DIFFX ** " + str(math.fabs(diffX))
      print "** DIFFY ** " + str(math.fabs(diffY))
      if math.fabs(diffX) < 45 and ball.fromTopCamera == False and ball.imageCenterY > 130: #90:
        integralAngleError = 0
        previous_ball_angle = 0
        ball_distance = ball.visionDistance
        previous_ball_distance = ball_distance
        commands.stand()
        self.postSignal(Choices.DetectGoal)
      else:
        # Move toward the ball with PID if its in a valid region, before the line
        if penalty_line.seen and penalty_line.radius > 910 and ball.imageCenterY < penalty_line.imageCenterY:
            commands.stand()
        else:
            errorAngle = ball.visionBearing
            derivativeError = errorAngle - previous_error
            previous_error = errorAngle
            moveAngle = (kp * errorAngle) + (ki * integralAngleError) + (kd * derivativeError) #PID controller
            integralAngleError += errorAngle
            commands.setWalkVelocity(0.3, 0.0, moveAngle)
    else:
      previous_error = 0
      integralAngleError = 0
      self.postSignal(Choices.Search) #search'''

# DRIBBLE and kick choose task
class ChooseNode(Node):
  def run(self):
    global angle
    global previous_error
    global previous_ball_angle
    global ball_distance
    global previous_ball_distance
    global integralAngleError
    
    goal = core.world_objects.getObjPtr(core.WO_OPP_GOAL)
    ball = core.world_objects.getObjPtr(core.WO_BALL)
    penalty_line = core.world_objects.getObjPtr(core.WO_OPP_PENALTY)
    print "** SEEN ** " + str(ball.seen)
    print "** imageX ** " + str(ball.imageCenterX)
    print "** imageY ** " + str(ball.imageCenterY)
    print "** TopCamera ** " + str(ball.fromTopCamera)
    '''print "** error ** " + str(ball.imageCenterX - 160)
    print "** Head Yaw Value ** %f" % percepts.joint_angles[core.HeadYaw]
    print "** TopCamera ** " + str(ball.fromTopCamera)'''
    
    commands.setWalkVelocity(0.0, 0.4, 0.0)
    '''commands.stand()
    robotX = 160
    robotY = 240
    diffX = robotX - ball.imageCenterX
    diffY = robotY - ball.imageCenterY
    if ball.seen:
      core.speech.say("Seen")
      print "** DIFFX ** " + str(math.fabs(diffX))
      print "** DIFFY ** " + str(math.fabs(diffY))

      if math.fabs(diffX) < 45 and ball.fromTopCamera == False and ball.imageCenterY > 110: #90:
        # reset variables before going to Goal Detection
        print "Go to goal detection "
        integralAngleError = 0
        previous_ball_angle = 0
        ball_distance = ball.visionDistance
        previous_ball_distance = ball_distance
        commands.stand()
        self.postSignal(Choices.DetectGoal)
      else:
        print "Move if valid region"
        # Move toward the ball with PID if its in a valid region, before the line
        if penalty_line.seen and penalty_line.radius > 910 and ball.imageCenterY < penalty_line.imageCenterY:
            commands.stand()
        else:
            print " ** Moving with PID **"
            errorAngle = ball.visionBearing
            derivativeError = errorAngle - previous_error
            previous_error = errorAngle
            moveAngle = (kp * errorAngle) + (ki * integralAngleError) + (kd * derivativeError) #PID controller
            integralAngleError += errorAngle
            commands.setWalkVelocity(0.25, 0.0, moveAngle)
    else:
      previous_error = 0
      integralAngleError = 0
      self.postSignal(Choices.Search) #search'''
    
# Dribble task
class DribbleAndKick(StateMachine):
  def setup(self):
    start = Node()
    choose = ChooseNode()
    search = SearchNode()
    forward = WalkForwardNode()
    detectGoal = DetectGoalNode()
    detectScore = DetectScore()
    finish = Node()
    align = AlignRightNode()
    
    self._adt(start, N, choose)
    self._adt(choose, S(Choices.Search), search, S, choose)
    self._adt(choose, S(Choices.DetectGoal), detectGoal)
    self._adt(detectGoal, S(Choices.WalkForward), forward)
    self._adt(forward, S(Choices.WalkForward), forward)
    self._adt(forward, S(Choices.LeftKick), LeftKickNode(), S, detectScore)
    self._adt(forward, S(Choices.RightKick), RightKickNode(), S, detectScore)
    self._adt(detectScore, S(Choices.Choose), choose)
    self._adt(detectScore, S(Choices.Finish), finish)
    self._adt(forward, S(Choices.Align), AlignRightNode())
    self._adt(align, S(Choices.Align), align)
    self._adt(align, S(Choices.LeftKick), LeftKickNode(), S, detectScore)
    self._adt(align, S(Choices.RightKick), RightKickNode(), S, detectScore)
    self._adt(align, S(Choices.Finish), finish)

class Choices:
  WalkForward = 1
  Search = 2
  DetectGoal = 3
  LeftKick = 4
  RightKick = 5
  DetectScore = 6
  Choose = 7
  Finish = 8
  Align = 9
  WalkForwardPenalty = 10
  NumChoices = 11


class DetectGoalNode(Node):
  def run(self):
    global previous_ball_angle
    global previous_ball_distance
    core.speech.say("Detect")
    goal = core.world_objects.getObjPtr(core.WO_OPP_GOAL)
    ball = core.world_objects.getObjPtr(core.WO_BALL)
    penalty_line = core.world_objects.getObjPtr(core.WO_OPP_PENALTY)
    print "*** GoAL seen ** " + str(goal.seen)
    print "*** GoAL x ** " + str(goal.imageCenterX)
    print "*** GoAL y ** " + str(goal.imageCenterY)
    print "*** Ball x ** " + str(ball.imageCenterX)
    print "*** Ball y ** " + str(ball.imageCenterY)
    print "*** GoAL radius ** " + str(goal.radius)
    print "*** GoAL radius ** " + str(goal.radius)
    
    #PD values for the angle
    align_kp = 0.3
    align_kd = 0.4
    #PD values for the y
    y_kp = 0.1
    y_kd = 0.1
    
    if not(goal.seen) or goal.radius < 1000: # or (math.fabs(goal.imageCenterX-ball.imageCenterX) > 40): #search for it
      print "ALIGN WITH PID"
      ball_error_angle = ball.visionBearing
      d_ball_angle = ball_error_angle - previous_ball_angle
      previous_ball_angle = ball_error_angle
      move_angle = align_kp * ball_error_angle + align_kd * d_ball_angle

      ball_error_distance = (ball.visionDistance - ball_distance)/100 #translation to use this in the x parameter for walkVelocity
      d_ball_distance = (ball.visionDistance - previous_ball_distance)/100
      previous_ball_distance = ball.visionDistance
      x = (160 - ball.imageCenterX)/100
      print "*** BALL ERROR DISTANCE *** " + str(ball_error_distance)
      commands.setWalkVelocity(ball_error_distance*y_kp + d_ball_distance*y_kd, 0.3*x, move_angle) #rotate around ball #y=0.3 initially
    else:
      print "WALK FORWARD"
      #core.speech.say("Goal")
      self.postSignal(Choices.WalkForward)
      #commands.stand()
      # move to Kick task
      
class LeftKickNode(Node):
  def __init__(self):
    super(LeftKickNode, self).__init__()
    self.task = kicks.Kick(core.Kick.LEFT, 700)
    
  def run(self):
    print "Left Kick"
    #core.speech.say("Left Kick")
    commands.stand()
    self.task.processFrame()
    if self.task.finished():
      self.postSuccess()
      
class RightKickNode(Node):
  def __init__(self):
    super(RightKickNode, self).__init__()
    self.task = kicks.Kick(core.Kick.RIGHT, 700)
    
  def run(self):
    print "Right Kick"
    #core.speech.say("Right Kick")
    commands.stand()
    self.task.processFrame()
    if self.task.finished():
      self.postSuccess()
    
class SearchNode(Node):
  def run(self):
    core.speech.say("Search")
    commands.setWalkVelocity(0.0, 0.0, 20 * core.DEG_T_RAD)
    if self.getTime() > 2:
      self.postSuccess()
      
class DetectScore(Node):
  def run(self):
    core.speech.say("Goal Scored!")
    ball = core.world_objects.getObjPtr(core.WO_BALL)
    goal = core.world_objects.getObjPtr(core.WO_OPP_GOAL)
    diff = goal.visionDistance - ball.visionDistance
    print " ** Score Distance ** " + str(diff)
    self.postSignal(Choices.Finish)

class AlignRightNode(Node):
  def run(self):
    global angle
    global previous_error
    global previous_ball_angle
    global ball_distance
    global previous_ball_distance
    global integralAngleError
    global prev_robot_angle
    core.speech.say("Align")
    print "*** ALIGNING "
    goal = core.world_objects.getObjPtr(core.WO_OPP_GOAL)
    ball = core.world_objects.getObjPtr(core.WO_BALL)
    robot = core.world_objects.getObjPtr(core.WO_OPPONENT1) #pink post-it
    
    penaltyLine = core.world_objects.getObjPtr(core.WO_OPP_PENALTY)
    robotX = 160
    robotY = 240
    diffX = robotX - ball.imageCenterX
    diffY = robotY - ball.imageCenterY
    commands.setStiffness()
    commands.stand()
    commands.setHeadTilt(-20) #tilt head down
    
    goalBallError = goal.imageCenterX - ball.imageCenterX
    #robot angle pid
    kp = 0.3
    robot_angle = robot.visionBearing
    r_error_angle = robot_angle#prev_robot_angle - robot_angle
    prev_robot_angle = robot_angle
    move_angle = kp*r_error_angle #move_angle based on pink sticker
    #if difference in x is less than 20, realign
    print "** ROBOT DIFFX " + str(diffX)
    print "** ROBOT X " + str(robot.imageCenterX)
    print "** ROBOT Y " + str(robot.imageCenterY)
    xerr = 160 - robot.imageCenterX
    print "**** XERR " + str(math.fabs(xerr))
    if math.fabs(160 - robot.imageCenterX) > 80:
        print "** FINISHED "
        if xerr >= 0:
           #self.postSignal(Choices.Align)
           self.postSignal(Choices.RightKick)
        else:
           #self.postSignal(Choices.Align)
           self.postSignal(Choices.LeftKick)
        #self.postSignal(Choices.Finish)
        #print "*** FINISHED ***"
        #commands.stand()
    else:
        print "____BALL SEEN " + str(ball.seen)
        print "____BALL x " + str(ball.imageCenterX)
        print "____BALL Y " + str(ball.imageCenterY)
        #re align maintain alignment with the ball:
        ball_error_angle = ball.visionBearing
        d_ball_angle = ball_error_angle - previous_ball_angle
        previous_ball_angle = ball_error_angle
        #ball_error_distance = (ball.visionDistance - ball_distance)/100 #translation to use this in the x parameter for walkVelocity
        #d_ball_distance = (ball.visionDistance - previous_ball_distance)/100
        previous_ball_distance = ball.visionDistance
        x = (160 - ball.imageCenterX)/100
        y = (120 - ball.imageCenterY)/100
        print "____x move " + str(x)
        print "____y move " + str(y)
        print "____move angle " + str(move_angle)
        print "*** BALL ERROR DISTANCE *** " + str(x)
        commands.setWalkVelocity(y*0.3, 0.3*x, move_angle) #rotate around ball #y=0.3 initially

# PENALTY: Walk forward(there's really very little walk forward)
class WalkForwardPenaltyNode(Node):
  def run(self):
    global angle
    global previous_error
    global previous_ball_angle
    global ball_distance
    global previous_ball_distance
    global integralAngleError
    core.speech.say("Walk Forward")
    goal = core.world_objects.getObjPtr(core.WO_OPP_GOAL)
    ball = core.world_objects.getObjPtr(core.WO_BALL)
    penaltyLine = core.world_objects.getObjPtr(core.WO_OPP_PENALTY)
    robotX = 160
    robotY = 240
    diffX = robotX - ball.imageCenterX
    diffY = robotY - ball.imageCenterY
    commands.setStiffness()
    commands.stand()
    commands.setHeadTilt(-20) #tilt head down
    #print "___** LINE SEEN  **" + str(penaltyLine.seen)
    #print "___** LINE X **" + str(penaltyLine.imageCenterX)
    #print "___** LINE Y **" + str(penaltyLine.imageCenterY)
    #print "___** LINE VISION DISTANCE **" + str(penaltyLine.visionDistance)
    #print "___** LINE RADIUS **" + str(penaltyLine.radius)
    goalBallError = goal.imageCenterX - ball.imageCenterX
    if ball.seen:
      print "** xaxis **" + str(math.fabs(diffX))
      print "** fromTopCamera **" + str(ball.fromTopCamera)
      print "** yaxis **" + str(ball.imageCenterY)
      print "** goalBall Alignment **" + str(goalBallError)
      print "** goalRadius **" + str(goal.radius)
      #if math.fabs(diffX) < 45 and ball.fromTopCamera == False and ball.imageCenterY > 175 and math.fabs(goalBallError) < 65 and goal.radius < 2500:
      if math.fabs(diffX) < 45 and ball.fromTopCamera == False and ball.imageCenterY > 210 and math.fabs(goalBallError) < 100:
        print "Kick Ball"
        previous_ball_angle = 0
        ball_distance = ball.visionDistance
        previous_ball_distance = ball_distance
        commands.stand()
        if diffX >= 0:
           #self.postSignal(Choices.Align)
           self.postSignal(Choices.RightKick)
        else:
           #self.postSignal(Choices.Align)
           self.postSignal(Choices.LeftKick)
      
      else:
        # Move toward the ball with PID
        errorAngle = ball.visionBearing #math.atan((diffX / diffY)) #radians errorAngle
        derivativeError = errorAngle - previous_error
        previous_error = errorAngle
        moveAngle = (kp * errorAngle) + (ki * integralAngleError) + (kd * derivativeError) #PID controller
        integralAngleError += errorAngle
        commands.setWalkVelocity(0.25, 0.3 * goalBallError/100, moveAngle)
        print "** WALK FORWARD ERROR ANGLE ** %f" % errorAngle
        self.postSignal(Choices.WalkForward)

#DRIBBLE AND KICK: Walk forward
class WalkForwardNode(Node):
  def run(self):
    global angle
    global previous_error
    global previous_ball_angle
    global ball_distance
    global previous_ball_distance
    global integralAngleError
    core.speech.say("Walk Forward")
    goal = core.world_objects.getObjPtr(core.WO_OPP_GOAL)
    ball = core.world_objects.getObjPtr(core.WO_BALL)
    penalty_line = core.world_objects.getObjPtr