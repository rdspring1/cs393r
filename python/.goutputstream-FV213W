from state import * 
import commands, core, util, pose, percepts, kicks
import time
import math

scoreDistance = 15
angle = 10
kp = 0.2
kd = 0.1
ki = 0.0

previous_error = 0
integralAngleError = 0

previous_ball_angle = 0

previous_ball_distance = 0
ball_distance = 0

prev_robot_angle = 0

#For Penalty task
class PenaltyKick(StateMachine):
  def setup(self):
    start = Node()
    choose = ChoosePenaltyNode()
    search = SearchNode()
    forward = WalkForwardPenaltyNode()
    detectGoal = DetectGoalNode()
    detectScore = DetectScore()
    finish = Node()
    align = AlignRightNode()
    
    self._adt(start, N, choose)
    self._adt(choose, S(Choices.Search), search, S, choose)
    self._adt(choose, S(Choices.DetectGoal), detectGoal)
    self._adt(detectGoal, S(Choices.WalkForwardPenalty), forward)
    self._adt(forward, S(Choices.WalkForwardPenalty), forward)
    self._adt(forward, S(Choices.LeftKick), LeftKickNode(), S, detectScore)
    self._adt(forward, S(Choices.RightKick), RightKickNode(), S, detectScore)
    self._adt(detectScore, S(Choices.Choose), choose)
    self._adt(detectScore, S(Choices.Finish), finish)
    self._adt(forward, S(Choices.Align), AlignRightNode())
    self._adt(align, S(Choices.Align), align)
    self._adt(align, S(Choices.LeftKick), LeftKickNode(), S, detectScore)
    self._adt(align, S(Choices.RightKick), RightKickNode(), S, detectScore)
    self._adt(align, S(Choices.Finish), finish)

#For Penalty task
class ChoosePenaltyNode(Node):
  def run(self):
    global angle
    global previous_error
    global previous_ball_angle
    global ball_distance
    global previous_ball_distance
    global integralAngleError
    
    goal = core.world_objects.getObjPtr(core.WO_OPP_GOAL)
    ball = core.world_objects.getObjPtr(core.WO_BALL)
    penalty_line = core.world_objects.getObjPtr(core.WO_OPP_PENALTY)

    #print "** seen line " + str(penalty_line.seen) + " top camera: " + str(penalty_line.fromTopCamera)
    commands.stand()
    commands.setHeadTilt(-10)
    #commands.setHeadTilt(-20) #tilt head down
    #commands.setWalkVelocity(0.4, 0.2, 0)
    '''if penalty_line.seen and penalty_line.imageCenterY > 160:
        print "** line x " + str(penalty_line.imageCenterX)
        print "** line y " + str(penalty_line.imageCenterY)
        print "** size of blob line " + str(penalty_line.radius)
        commands.stand()
    else:
        commands.setWalkVelocity(0.4, 0.2, 0)'''
    #commands.setWalkVelocity(0.4, 0.0, 0)
    print "** SEEN ** " + str(ball.seen)
    print "** imageX ** " + str(ball.imageCenterX)
    print "** imageY ** " + str(ball.imageCenterY)

    robotX = 160
    robotY = 240
    diffX = robotX - ball.imageCenterX
    diffY = robotY - ball.imageCenterY
    if ball.seen:
      core.speech.say("Seen")
      print "** DIFFX ** " + str(math.fabs(diffX))
      print "** DIFFY ** " + str(math.fabs(diffY))
      if math.fabs(diffX) < 45 and ball.fromTopCamera == False and ball.imageCenterY > 130: #90:
        integralAngleError = 0
        previous_ball_angle = 0
        ball_distance = ball.visionDistance
        previous_ball_distance = ball_distance
        commands.stand()
        self.postSignal(Choices.DetectGoal)
      else:
        # Move toward the ball with PID if its in a valid region, before the line
        if penalty_line.seen and penalty_line.radius > 910 and ball.imageCenterY < penalty_line.imageCenterY:
            commands.stand()
        else:
            errorAngle = ball.visionBearing
            derivativeError = errorAngle - previous_error
            previous_error = errorAngle
            moveAngle = (kp * errorAngle) + (ki * integralAngleError) + (kd * derivativeError) #PID controller
            integralAngleError += errorAngle
            commands.setWalkVelocity(0.3, 0.0, moveAngle)
    else:
      previous_error = 0
      integralAngleError = 0
      self.postSignal(Choices.Search) #search'''

# DRIBBLE and kick choose task
class ChooseNode(Node):
  def run(self):
    global angle
    global previous_error
    global previous_ball_angle
    global ball_distance
  